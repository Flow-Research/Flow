# Flow Tests - Testing Standards and Patterns
# Rules for writing tests

## Testing Philosophy

Flow uses comprehensive testing at multiple levels:
1. **Unit tests** - Individual functions/components (in src/)
2. **Integration tests** - Module interactions (in tests/)
3. **Property tests** - Generative testing for invariants
4. **Multi-node tests** - Concurrent node scenarios

Target: >80% coverage on critical paths

## Test Organization

```
tests/
├── api/              # API endpoint tests (REST, WebSocket)
├── bootstrap/        # Initialization and config tests
├── modules/          # Module-specific integration tests
│   └── ssi/         # SSI/DID/WebAuthn tests
└── util/            # Test utilities and helpers
```

## Unit Test Patterns (in src/)

### Location
Place unit tests in same file as code:
```rust
// src/modules/network/manager.rs

pub struct NetworkManager { /* ... */ }

impl NetworkManager { /* ... */ }

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_config_validation() { /* ... */ }
    
    #[tokio::test]
    async fn test_lifecycle() { /* ... */ }
}
```

### Isolation
Use tempfile for filesystem operations:
```rust
#[test]
fn test_rocksdb_store() {
    let temp_dir = TempDir::new().unwrap();
    let store = RocksDbStore::new(temp_dir.path(), config).unwrap();
    
    store.put(b"key", b"value").unwrap();
    assert_eq!(store.get(b"key").unwrap(), Some(b"value".to_vec()));
    
    // temp_dir automatically cleaned up on drop
}
```

## Integration Test Patterns (in tests/)

### Multi-Node Scenarios (CRITICAL for Networking)

REQUIRED for network module changes:
```rust
// tests/modules/network/multi_node.rs

#[tokio::test]
async fn test_two_nodes_discover_via_dht() {
    // Setup isolated test environments
    let temp1 = TempDir::new().unwrap();
    let temp2 = TempDir::new().unwrap();
    
    // Create two network managers
    let node1_data = create_test_node_data("node1");
    let node2_data = create_test_node_data("node2");
    
    let manager1 = NetworkManager::new(&node1_data).await.unwrap();
    let manager2 = NetworkManager::new(&node2_data).await.unwrap();
    
    // Configure with different ports
    let config1 = NetworkConfig {
        listen_port: 0, // OS assigns
        enable_quic: true,
        bootstrap_peers: vec![],
    };
    
    let config2 = NetworkConfig {
        listen_port: 0,
        enable_quic: true,
        bootstrap_peers: vec![manager1_addr], // Bootstrap from node1
    };
    
    // Start both
    manager1.start(&config1).await.unwrap();
    manager2.start(&config2).await.unwrap();
    
    // Wait for discovery
    tokio::time::sleep(Duration::from_secs(5)).await;
    
    // Verify connection
    assert_eq!(manager1.peer_count().await.unwrap(), 1);
    assert_eq!(manager2.peer_count().await.unwrap(), 1);
    
    // Verify bidirectional
    let peers1 = manager1.connected_peers().await.unwrap();
    let peers2 = manager2.connected_peers().await.unwrap();
    
    assert_eq!(peers1[0].peer_id, node2_data.peer_id);
    assert_eq!(peers2[0].peer_id, node1_data.peer_id);
    
    // Clean shutdown
    manager1.stop().await.unwrap();
    manager2.stop().await.unwrap();
}
```

### Test Helpers (Reusable Setup)

Create helpers in tests/util/ or tests/api/helpers.rs:
```rust
// tests/api/rest/helpers.rs

pub async fn setup_test_app() -> (AppState, TempDir) {
    let temp_dir = TempDir::new().unwrap();
    
    // Setup database
    let db = setup_test_db(&temp_dir).await;
    
    // Setup KV store
    let kv = setup_test_kv(&temp_dir).await;
    
    // Create node
    let node = Node::new(/* ... */);
    
    // Create app state
    let app_state = AppState::new(node);
    
    (app_state, temp_dir)
}

pub async fn create_space_request(
    app_state: &AppState,
    directory: &str,
) -> Response {
    let app = build_router(app_state.clone());
    
    let request = Request::builder()
        .method("POST")
        .uri("/api/v1/spaces")
        .header("content-type", "application/json")
        .body(Body::from(format!(r#"{{"directory":"{}"}}"#, directory)))
        .unwrap();
    
    app.oneshot(request).await.unwrap()
}
```

## Async Test Patterns

### tokio::test
```rust
#[tokio::test]
async fn test_async_operation() {
    let result = async_function().await;
    assert!(result.is_ok());
}

// With timeout
#[tokio::test]
async fn test_with_timeout() {
    let result = tokio::time::timeout(
        Duration::from_secs(5),
        slow_operation(),
    ).await;
    
    assert!(result.is_ok(), "Operation timed out");
}
```

## Serial Tests (Environment Variables)

Use serial_test crate for tests that modify global state:
```rust
use serial_test::serial;

#[test]
#[serial]
fn test_config_from_env() {
    unsafe {
        env::set_var("KEY", "value");
    }
    
    let config = Config::from_env().unwrap();
    assert_eq!(config.key, "value");
    
    unsafe {
        env::remove_var("KEY");
    }
}
```

## Concurrent Test Patterns

### Race Condition Testing
```rust
#[tokio::test]
async fn test_concurrent_appends() {
    let store = Arc::new(create_test_store());
    
    let handles: Vec<_> = (0..10)
        .map(|i| {
            let store = Arc::clone(&store);
            tokio::spawn(async move {
                for j in 0..100 {
                    store.append(create_payload(i, j)).await.unwrap();
                }
            })
        })
        .collect();
    
    // Wait for all
    for handle in handles {
        handle.await.unwrap();
    }
    
    // Verify correctness
    assert_eq!(store.event_count().await.unwrap(), 1000);
    
    // Verify integrity (hash chain, etc.)
    let events = store.iter_events().await.unwrap().collect::<Vec<_>>();
    assert!(verify_hash_chain(&events));
}
```

## Property-Based Testing

Use proptest for invariant testing:
```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn test_event_hash_deterministic(
        message in any::<String>(),
        count in any::<i32>(),
    ) {
        let event1 = create_event(&message, count);
        let event2 = create_event(&message, count);
        
        let hash1 = event1.compute_hash().unwrap();
        let hash2 = event2.compute_hash().unwrap();
        
        prop_assert_eq!(hash1, hash2);
    }
}
```

## Test Coverage Requirements

### Critical Paths (Must Have >80% Coverage)
- Network lifecycle (start/stop/restart scenarios)
- Event store append operations (concurrent + sequential)
- Peer discovery and connection establishment
- Authentication flows (WebAuthn registration/authentication)
- Space creation and indexing
- API request/response handling

### Test Types Per Module

**Network Module:**
- [ ] Unit: config validation, keypair conversion, peer registry operations
- [ ] Integration: 2-node connection, 3-node discovery, graceful shutdown
- [ ] Concurrency: parallel connection attempts, concurrent peer registry updates
- [ ] Persistence: peer registry survives restart, DHT state persists

**API Module:**
- [ ] Unit: handler input validation, error responses
- [ ] Integration: full HTTP request/response cycle for each endpoint
- [ ] Edge cases: malformed JSON, missing fields, concurrent requests

**Storage Module:**
- [ ] Unit: CRUD operations, iterator correctness
- [ ] Integration: persistence across reopens
- [ ] Concurrency: parallel reads/writes, transaction isolation
- [ ] Capacity: large datasets, large values

## Test Naming

Use descriptive names:
```rust
// GOOD
#[test]
fn test_create_space_with_invalid_directory_returns_error() { /* ... */ }

#[tokio::test]
async fn test_two_nodes_discover_via_bootstrap_peer() { /* ... */ }

// BAD (too vague)
#[test]
fn test_space() { /* ... */ }

#[test]
fn test_1() { /* ... */ }
```

## Test Documentation

Document complex test scenarios:
```rust
/// Tests that the peer registry correctly handles reconnection counts
/// across multiple connection/disconnection cycles.
/// 
/// Scenario:
/// 1. Node A connects to Node B
/// 2. Node A disconnects
/// 3. Node A reconnects to Node B
/// 4. Verify reconnection_count incremented
#[tokio::test]
async fn test_peer_registry_reconnection_tracking() {
    // ...
}
```

## Avoid Flaky Tests

### Use Explicit Waits
```rust
// BAD: Fixed sleep (brittle)
tokio::time::sleep(Duration::from_millis(100)).await;
assert_eq!(peer_count, 1);

// GOOD: Poll with timeout
let deadline = Instant::now() + Duration::from_secs(5);
loop {
    if manager.peer_count().await.unwrap() == 1 {
        break;
    }
    if Instant::now() > deadline {
        panic!("Timeout waiting for peer connection");
    }
    tokio::time::sleep(Duration::from_millis(100)).await;
}
```

### Isolate Test State
```rust
// GOOD: Each test gets own temp directory and DB
#[tokio::test]
async fn test_a() {
    let temp = TempDir::new().unwrap(); // Unique per test
    let store = create_store(temp.path()).unwrap();
    // ...
}

#[tokio::test]
async fn test_b() {
    let temp = TempDir::new().unwrap(); // Different from test_a
    let store = create_store(temp.path()).unwrap();
    // ...
}
```

## Test Verification Checklist

Before submitting tests:
- [ ] Tests are isolated (no shared global state)
- [ ] Async tests use #[tokio::test]
- [ ] Filesystem operations use tempfile
- [ ] Environment variable tests use #[serial]
- [ ] Multi-node tests verify bidirectional behavior
- [ ] Concurrent tests verify thread-safety
- [ ] Tests have descriptive names
- [ ] Complex scenarios have documentation
- [ ] No hardcoded timeouts (use polling with timeout)
- [ ] Tests clean up resources (files, network connections)
- [ ] Coverage meets >80% for new code on critical paths
