# Flow - Decentralized Coordination Platform
# Root AI Assistant Rules

## Project Identity
Project: Flow
Description: Decentralized coordination platform for agents and users to co-create, manage, and reward knowledge, tasks, and compute in a verifiable, local-first environment
Languages: Rust (backend/networking), TypeScript (UI)
Architecture: Monorepo - Rust workspace (back-end) + TypeScript frontends (user-interface)

## Core Architectural Principles

### 1. Local-First & Verifiable
- All operations must work offline-first
- Every state change is cryptographically verifiable
- P2P networking via libp2p (not client-server)
- DIDs for identity, Capability based access control

### 2. Modularity & Clean Interfaces
- Clear separation between layers (network, storage, business logic, API)
- Public interfaces hide implementation details
- Configuration, construction, and runtime are separate concerns
- Each module has well-defined boundaries and responsibilities

### 3. Production-Ready Code
- No toy examples or pseudocode
- Idiomatic Rust: use Result/Option, not unwrap() without justification
- Comprehensive error handling with context
- Structured logging via tracing (not println!)
- Thread-safe by design: Arc, RwLock, Mutex, channels

### 4. Test-Driven Design
- Write tests alongside implementation, not after
- Unit tests for components, integration tests for interactions
- >80% coverage on critical paths
- Use tempfile for filesystem isolation in tests
- Use serial_test for tests that modify global state

## Rust Code Standards

### Error Handling
```rust
// REQUIRED: Use AppError from errors crate
use errors::AppError;

pub fn operation() -> Result<Data, AppError> {
    inner_op()
        .map_err(|e| AppError::Network(format!("Operation failed: {}", e)))?;
    Ok(data)
}

// FORBIDDEN: Generic errors, panic in production
```

### Async Patterns
```rust
// REQUIRED: Tokio patterns
use tokio::sync::{RwLock, mpsc};
use std::sync::Arc;

// Thread-safe shared state
let state = Arc::new(RwLock::new(State::new()));

// Message passing for coordination
let (tx, rx) = mpsc::unbounded_channel();

// FORBIDDEN: Blocking in async
std::thread::sleep(Duration::from_secs(1)); // ❌
tokio::time::sleep(Duration::from_secs(1)).await; // ✅
```

### Logging
```rust
// REQUIRED: Structured logging with tracing
use tracing::{info, warn, error, debug, instrument};

#[instrument(skip(data), fields(id = %entity_id))]
pub async fn process(entity_id: &str, data: Vec<u8>) {
    debug!(bytes = data.len(), "Processing started");
    info!("Process complete");
}

// FORBIDDEN: println!, eprintln!, unstructured logs
```

### Lifecycle Management
```rust
// REQUIRED PATTERN for services
pub struct Service {
    state: Arc<RwLock<State>>,
    shutdown_tx: Option<oneshot::Sender<()>>,
    task_handle: Option<JoinHandle<()>>,
}

impl Service {
    pub fn new(config: Config) -> Result<Self, AppError> { /* ... */ }
    
    pub async fn start(&mut self) -> Result<(), AppError> {
        // Spawn background task, store handle
        let handle = tokio::spawn(async move { /* ... */ });
        self.task_handle = Some(handle);
        Ok(())
    }
    
    pub async fn stop(&mut self) -> Result<(), AppError> {
        // Send shutdown signal
        if let Some(tx) = self.shutdown_tx.take() {
            let _ = tx.send(());
        }
        // Wait for task completion
        if let Some(handle) = self.task_handle.take() {
            handle.await?;
        }
        Ok(())
    }
}

// FORBIDDEN: Untracked background tasks, unclear shutdown
```

## Storage Standards

### RocksDB (All Persistent Storage)
- Use column families for logical separation
- Always flush on graceful shutdown
- Use tempfile::TempDir for test isolation
- Never open same DB from multiple processes

```rust
use rocksdb::{DB, Options, ColumnFamilyDescriptor};

let cfs = vec![
    ColumnFamilyDescriptor::new("cf_name", Options::default()),
];
let db = Arc::new(DB::open_cf_descriptors(&opts, path, cfs)?);
```

## Documentation Requirements

### Code Documentation
- Public APIs: Doc comments (///) explaining purpose, parameters, returns, errors
- Complex logic: Inline comments explaining "why", not "what"
- Breaking changes: Update CHANGELOG.md immediately

### Technical Reports (When Explaining/Designing Code)
When the AI generates technical explanations, design documents, or implementation plans, use this 7-section structure:

1. **High-Level Design** (2-4 sentences goal + key components + runtime interaction)
2. **Data Structures and Types** (structs, enums, type aliases with 1-2 sentence purpose)
3. **Step-by-Step Implementation Plan** (numbered, concrete steps)
4. **Code Changes by File** (FILE: path format with code blocks)
5. **Tests** (unit + integration test code)
6. **Usage Example** (short example of using the new code)
7. **Notes and Trade-offs** (limitations, future extensibility notes)

## Git & PR Standards
- Commits: Conventional Commits (feat:, fix:, refactor:, perf:, test:, docs:)
- PRs: Fill all template sections (Description, Type, Breaking Changes, Tests)
- Never commit secrets, always use environment variables
- Update CHANGELOG.md for user-facing changes

## Scope Discipline
When working on a specific work item:
- Stay strictly focused on that item
- Do not implement unrelated features
- Do not refactor unrelated code unless explicitly asked
- Mention follow-up work in "Notes" section, don't implement it

## Performance & Security
- Profile before optimizing (use cargo flamegraph)
- Input validation on all external data
- Rate limiting on public APIs
- Path traversal prevention for file operations
- Secrets never in code or logs

## Verification Checklist (AI Must Check Before Responding)

Before generating code or explanations, verify:

### Networking Code
- [ ] Has clear lifecycle (new/start/stop with no leaked tasks)
- [ ] Shared state is thread-safe (Arc + RwLock/Mutex or channels)
- [ ] Includes telemetry logs (info/debug/warn/error at appropriate levels)
- [ ] Compatible with future features (GossipSub, mDNS, network state exposure)
- [ ] Follows NetworkManager patterns (if applicable)

### All Code
- [ ] Error handling uses AppError with context
- [ ] No unwrap() without justification
- [ ] Async code doesn't block executor
- [ ] Tests included (unit for components, integration for interactions)
- [ ] Fits existing module boundaries

### Technical Explanations
- [ ] Follows 7-section structure if applicable
- [ ] Code snippets are production-ready, not pseudocode
- [ ] Includes comprehensive test coverage
- [ ] Notes future extensibility

## Common Anti-Patterns to AVOID
- ❌ Global mutable state
- ❌ Panics in production code (use Result/Option)
- ❌ Blocking operations in async contexts
- ❌ Tight coupling between layers
- ❌ Untracked background tasks
- ❌ Missing error context
- ❌ Functions >50 lines without good reason
- ❌ println!/eprintln! instead of tracing
